import sys
import random
from time import perf_counter


def tour_length(G, path):
    """
    Compute the total length of a tour, including return to the start.

    Parameters:
        G (dict): Graph adjacency dictionary.
        path (list): Ordered list of nodes representing the tour (no closing repeat).

    Returns:
        float: Total path length.
    """
    total = 0
    for i in range(len(path) - 1):
        total += G[path[i]][path[i + 1]]
    total += G[path[-1]][path[0]]
    return total


def nearest_neighbor(G, nodes, start=None, k=2):
    """
    Construct a tour using a randomized Nearest Neighbor heuristic.

    Instead of always picking the absolute nearest node, this version
    picks randomly among the k nearest nodes to introduce diversity.

    Parameters:
        G (dict): Graph adjacency dictionary.
        nodes (set): All nodes in the graph.
        start (str, optional): Starting node. If None, chosen randomly.
        k (int): Number of nearest candidates to consider randomly.

    Returns:
        list: A tour generated by visiting nodes with randomized nearest neighbor.
    """
    if start is None:
        start = random.choice(list(nodes))
    unvisited = set(nodes)
    unvisited.remove(start)

    path = [start]
    current = start

    while unvisited:
        sorted_nodes = sorted(unvisited, key=lambda x: G[current][x])
        candidates = sorted_nodes[:min(k, len(sorted_nodes))]
        next_node = random.choice(candidates)
        path.append(next_node)
        unvisited.remove(next_node)
        current = next_node

    return path


def best_nearest_neighbor(G, nodes, restarts=10, k=2):
    """
    Run randomized nearest neighbor multiple times and keep the best tour.

    Parameters:
        G (dict): Graph adjacency dictionary.
        nodes (set): All nodes in the graph.
        restarts (int): Number of randomized restarts.
        k (int): Number of nearest candidates to consider randomly.

    Returns:
        list: Best tour found among all restarts.
    """
    best_path = None
    best_len = float("inf")

    for _ in range(restarts):
        path = nearest_neighbor(G, nodes, k=k)
        length = tour_length(G, path)
        if length < best_len:
            best_len = length
            best_path = path

    return best_path

def two_opt(G, path, max_iter=1000, allow_random_jump=True):
    """
    Perform 2-opt optimization with occasional random acceptance.

    This version of 2-opt sometimes accepts worse moves (with small probability)
    to escape local minima, similar to simulated annealing.

    Parameters:
        G (dict): Graph adjacency dictionary.
        path (list): Initial TSP tour (no closing repeat).
        max_iter (int): Maximum number of iterations.
        allow_random_jump (bool): Whether to allow occasional random acceptance.

    Returns:
        list: Locally optimized tour.
    """
    improved = True
    iters = 0
    while improved and iters < max_iter:
        improved = False
        iters += 1
        for i in range(1, len(path) - 2):
            for j in range(i + 1, len(path) - 1):
                if j - i == 1:
                    continue
                d1 = G[path[i - 1]][path[i]] + G[path[j]][path[j + 1]]
                d2 = G[path[i - 1]][path[j]] + G[path[i]][path[j + 1]]

                if d2 < d1 or (allow_random_jump and random.random() < 0.01):
                    path[i:j + 1] = reversed(path[i:j + 1])
                    improved = True
    return path

def canonical_cycle(path):
    """
    Canonicalize the cycle:
    - Rotate so the lexicographically smallest node is first.
    - Choose the lexicographically smaller orientation (forward vs reversed).

    Parameters:
        path (list): Tour path (no closing repeat).

    Returns:
        list: Canonicalized tour path (no closing repeat).
    """
    if not path:
        return path

    # Find index of lexicographically smallest node
    min_index = min(range(len(path)), key=lambda i: path[i])

    # Forward rotation
    fwd = path[min_index:] + path[:min_index]

    # Reverse rotation (keep same start node, but reverse the order)
    rev_path = list(reversed(path))
    # Recompute index of the start node in the reversed path
    min_index_rev = rev_path.index(fwd[0])
    rev = rev_path[min_index_rev:] + rev_path[:min_index_rev]

    # Pick lexicographically smaller orientation
    return fwd if fwd < rev else rev


def main(testing=False):
    """
    Parse input, build the graph, run Nearest Neighbor + 2-opt,
    and print the best approximate TSP tour.

    Parameters:
        testing (bool): If True, print only runtime instead of solution.
    """
    G = {}
    nodes = set()

    # Read number of vertices and edges
    v, e = input().strip().split()
    v, e = int(v), int(e)

    # Build adjacency dictionary
    for _ in range(e):
        v1, v2, ew = input().split()
        ew = float(ew)
        if v1 not in G:
            G[v1] = {}
        if v2 not in G:
            G[v2] = {}
        G[v1][v2] = ew
        G[v2][v1] = ew
        nodes.add(v1)
        nodes.add(v2)

    start = perf_counter()

    # Step 1: Multi-start nearest neighbor + random restarts
    nn_path = best_nearest_neighbor(G, nodes, restarts=20, k=3)

    # Step 2: Run 2-opt for local improvement
    opt_path = two_opt(G, nn_path, max_iter=2000, allow_random_jump=True)

    # Step 3: Canonical cycle (no closing repeat)
    best_path = canonical_cycle(opt_path)

    # Compute final path length (matches printed cycle)
    best = tour_length(G, best_path)

    delta = perf_counter() - start

    if not testing:
        # Print length and cycle with explicit closing node for display only
        print(f"{best:.4f}")
        print(" ".join(best_path + [best_path[0]]))
    else:
        print(f"Execution time for {v} locations: {delta:.10f} seconds")


if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[-1] == "test":
        main(True)
    else:
        main()
