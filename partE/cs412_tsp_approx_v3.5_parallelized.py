import sys
import random
from time import perf_counter
from concurrent.futures import ProcessPoolExecutor, as_completed


def tour_length(G, path):
    """
    Compute the total length of a tour, including return to the start.

    Parameters:
        G (dict): Graph adjacency dictionary.
        path (list): Ordered list of nodes representing the tour (no closing repeat).

    Returns:
        float: Total path length.
    """
    total = 0
    for i in range(len(path) - 1):
        total += G[path[i]][path[i + 1]]
    total += G[path[-1]][path[0]]
    return total


def nearest_neighbor(G, nodes, start=None, k=2):
    """
    Construct a tour using a randomized Nearest Neighbor heuristic.

    Instead of always picking the absolute nearest node, this version
    picks randomly among the k nearest nodes to introduce diversity.

    Parameters:
        G (dict): Graph adjacency dictionary.
        nodes (set): All nodes in the graph.
        start (str, optional): Starting node. If None, chosen randomly.
        k (int): Number of nearest candidates to consider randomly.

    Returns:
        list: A tour generated by visiting nodes with randomized nearest neighbor.
    """
    if start is None:
        start = random.choice(list(nodes))
    unvisited = set(nodes)
    unvisited.remove(start)

    path = [start]
    current = start

    while unvisited:
        sorted_nodes = sorted(unvisited, key=lambda x: G[current][x])
        candidates = sorted_nodes[:min(k, len(sorted_nodes))]
        next_node = random.choice(candidates)
        path.append(next_node)
        unvisited.remove(next_node)
        current = next_node

    return path


def best_nearest_neighbor(G, nodes, restarts=10, k=2):
    """
    Run randomized nearest neighbor multiple times and keep the best tour.

    Parameters:
        G (dict): Graph adjacency dictionary.
        nodes (set): All nodes in the graph.
        restarts (int): Number of randomized restarts.
        k (int): Number of nearest candidates to consider randomly.

    Returns:
        list: Best tour found among all restarts.
    """
    best_path = None
    best_len = float("inf")

    for _ in range(restarts):
        path = nearest_neighbor(G, nodes, k=k)
        length = tour_length(G, path)
        if length < best_len:
            best_len = length
            best_path = path

    return best_path


def two_opt(G, path, max_iter=1000, allow_random_jump=True):
    """
    Perform 2-opt optimization with occasional random acceptance.

    This version of 2-opt sometimes accepts worse moves (with small probability)
    to escape local minima, similar to simulated annealing.

    Parameters:
        G (dict): Graph adjacency dictionary.
        path (list): Initial TSP tour (no closing repeat).
        max_iter (int): Maximum number of iterations.
        allow_random_jump (bool): Whether to allow occasional random acceptance.

    Returns:
        list: Locally optimized tour.
    """
    improved = True
    iters = 0
    while improved and iters < max_iter:
        improved = False
        iters += 1
        for i in range(1, len(path) - 2):
            for j in range(i + 1, len(path) - 1):
                if j - i == 1:
                    continue
                d1 = G[path[i - 1]][path[i]] + G[path[j]][path[j + 1]]
                d2 = G[path[i - 1]][path[j]] + G[path[i]][path[j + 1]]

                if d2 < d1 or (allow_random_jump and random.random() < 0.01):
                    path[i:j + 1] = reversed(path[i:j + 1])
                    improved = True
    return path


def canonical_cycle(path):
    """
    Canonicalize the cycle:
    - Rotate so the lexicographically smallest node is first.
    - Choose the lexicographically smaller orientation (forward vs reversed).

    Parameters:
        path (list): Tour path (no closing repeat).

    Returns:
        list: Canonicalized tour path (no closing repeat).
    """
    if not path:
        return path

    # Find index of lexicographically smallest node
    min_index = min(range(len(path)), key=lambda i: path[i])

    # Forward rotation
    fwd = path[min_index:] + path[:min_index]

    # Reverse rotation (keep same start node, but reverse the order)
    rev_path = list(reversed(path))
    # Recompute index of the start node in the reversed path
    min_index_rev = rev_path.index(fwd[0])
    rev = rev_path[min_index_rev:] + rev_path[:min_index_rev]

    # Pick lexicographically smaller orientation
    return fwd if fwd < rev else rev


def single_run(G, nodes):
    """
    Perform one randomized run of the solver:
    nearest neighbor + 2-opt + canonical cycle.
    Returns (length, path).
    """
    nn_path = best_nearest_neighbor(G, nodes, restarts=20, k=3)
    opt_path = two_opt(G, nn_path, max_iter=2000, allow_random_jump=True)
    candidate_path = canonical_cycle(opt_path)
    candidate_len = tour_length(G, candidate_path)
    return candidate_len, candidate_path


def main(testing=False, runs=50):
    """
    Parse input, build the graph, run solver multiple times in parallel,
    and keep the best approximate TSP tour.
    """
    G = {}
    nodes = set()

    # Read number of vertices and edges
    v, e = input().strip().split()
    v, e = int(v), int(e)

    # Build adjacency dictionary
    for _ in range(e):
        v1, v2, ew = input().split()
        ew = float(ew)
        if v1 not in G:
            G[v1] = {}
        if v2 not in G:
            G[v2] = {}
        G[v1][v2] = ew
        G[v2][v1] = ew
        nodes.add(v1)
        nodes.add(v2)

    start = perf_counter()

    best_len = float("inf")
    best_path = None

    # Run solver in parallel
    with ProcessPoolExecutor() as executor:
        futures = [executor.submit(single_run, G, nodes) for _ in range(runs)]
        for f in as_completed(futures):
            candidate_len, candidate_path = f.result()
            if candidate_len < best_len:
                best_len = candidate_len
                best_path = candidate_path

    delta = perf_counter() - start

    if not testing:
        print(f"{best_len:.4f}")
        print(" ".join(best_path + [best_path[0]]))
    else:
        print(f"Execution time for {v} locations over {runs} runs: {delta:.10f} seconds")


if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[-1] == "test":
        main(True)
    else:
        main()
