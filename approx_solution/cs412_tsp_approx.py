"""
Approximating algorithm for finding the shortest path
in the traveling salesperson problem.

This implementation uses a two-stage heuristic:
1. (Nearest Neighbor) Construct an initial tour by always choosing the closest
   unvisited node.
2. (Two-opt) Repeatedly improve the tour by reversing segments if
   doing so shortens the total path length.


This algorithm runs in polynomial time and scales far better than brute-force
enumeration, while GENERALLY producing high-quality tours.

"""

# Approximation Algorithm: iterative improvement
# Repeatedly try swapping two edges to reduce total distance.
# Stop when no improvements remain.


from time import perf_counter
import sys
import math


def distance(G, a, b):
    """
    Return the distance (edge weight) between nodes a and b.

    Parameters:
        G (dict): Graph adjacency dictionary.
        a (str): First node.
        b (str): Second node.

    Returns:
        float: Weight of the edge (a, b).
    """
    return G[a][b]


def tour_length(G, path):
    """
    Compute the total length of a tour, including return to the start.

    Parameters:
        G (dict): Graph adjacency dictionary.
        path (list): Ordered list of nodes representing the tour.

    Returns:
        float: Total path length.
    """
    total = 0
    for i in range(len(path) - 1):
        total += distance(G, path[i], path[i + 1])
    # return to start
    total += distance(G, path[-1], path[0])
    return total

# Heuristic number 1
def nearest_neighbor(G, nodes):
    """
    Compute an initial TSP path using the Nearest Neighbor heuristic.

    Parameters:
        G (dict): Graph adjacency dictionary.
        nodes (set): All nodes in the graph.

    Returns:
        list: A tour generated by repeatedly visiting the nearest unvisited node.
    """
    # Start at an arbitrary node
    start = next(iter(nodes))
    unvisited = set(nodes)
    unvisited.remove(start)

    path = [start]
    current = start

    # Repeatedly pick the closest unvisited node
    while unvisited:
        next_node = min(unvisited, key=lambda x: distance(G, current, x))
        path.append(next_node)
        unvisited.remove(next_node)
        current = next_node

    return path

# Heuristic number 2
def two_opt(G, path):
    """
    Perform 2-opt optimization on the given TSP path.

    2-opt attempts to improve the path by removing crossing edges.
    It repeatedly tries reversing path segments and keeps any change
    that reduces total tour length.

    Parameters:
        G (dict): Graph adjacency dictionary.
        path (list): Initial TSP tour.

    Returns:
        list: Locally optimized tour.
    """
    improved = True
    best_path = path[:]
    best_len = tour_length(G, best_path)

    # Continue until no improvements can be made
    while improved:
        improved = False

        # Try all possible edge pair swaps
        for i in range(1, len(best_path) - 2):
            for j in range(i + 1, len(best_path) - 1):

                # Skip adjacent edges (no improvement possible)
                if j - i == 1:
                    continue

                # Create new candidate path by reversing the segment
                new_path = best_path[:]
                new_path[i:j] = reversed(best_path[i:j])

                new_len = tour_length(G, new_path)

                # Accept the improvement
                if new_len < best_len:
                    best_len = new_len
                    best_path = new_path
                    improved = True
                    break  # restart search
            if improved:
                break

    return best_path


def main(testing=False):
    """
    Parse input, build the graph, run Nearest Neighbor + 2-opt,
    and print the best approximate TSP tour.

    Parameters:
        testing (bool): If True, print only runtime instead of solution.
    """
    G = {}
    nodes = set()

    # Read number of vertices and edges
    v, e = input().strip().split()
    v, e = int(v), int(e)

    # Build adjacency dictionary
    for _ in range(e):
        v1, v2, ew = input().split()
        ew = float(ew)

        # Insert nodes if not present
        if v1 not in G:
            G[v1] = {}
        if v2 not in G:
            G[v2] = {}

        # Undirected graph: add both directions
        G[v1][v2] = ew
        G[v2][v1] = ew

        nodes.add(v1)
        nodes.add(v2)

    start = perf_counter()

    # Step 1: Build initial path using Nearest Neighbor
    nn_path = nearest_neighbor(G, nodes)

    # Step 2: Run 2-opt for local improvement
    opt_path = two_opt(G, nn_path)

    # Compute final path length and cycle
    best = tour_length(G, opt_path)
    best_path = opt_path + [opt_path[0]]

    delta = perf_counter() - start

    # Print results
    if not testing:
        print(f"{best:.4f}")
        print(" ".join(best_path))
    else:
        print(f"Execution time for {v} locations: {delta:.10f} seconds")


if __name__ == "__main__":
    if sys.argv[-1] == "test":
        main(True)
    else:
        main()
